#!/usr/bin/env ruby
#================================================================================================================================
#
# Ruby Compiler Compiler (rcc)
#
# Copyright 2007 Chris Poirier (cpoirier@gmail.com)
# Licensed under the Academic Free License version 2.1
#
#================================================================================================================================

   $LOAD_PATH << File.expand_path( "#{File.dirname($0)}/../" )
      
   require "rcc/environment.rb"
   require "rcc/model/grammar.rb"
   require "rcc/interpreter/lexer.rb"
   require "rcc/interpreter/parser.rb"

   if ARGV.empty? then
      puts "USAGE: #{File.basename($0)} <grammar file> (explain? <mode>)?"
      puts "MODES: lex"
      exit 10
   end
   

   #
   # Load and compile the grammar.
   
   grammar_path = ARGV.shift
   grammar      = RCC::Model::Grammar.load_from_file( File.basename(grammar_path), grammar_path )
   grammar.display( STDOUT )


   #
   # Compile the parser plan.
   
   $show_statistics = true
   
   parser_plan = grammar.compile_plan()
   parser_plan.compile_actions( true )
   
   STDOUT.puts ""
   STDOUT.puts ""
   STDOUT.puts ""
   
   
   #
   # Process the input.  If mode is "lex", we will run the lexer over the input and do no parsing.
   # Otherwise, we parse.
   
   explain = false
   if ARGV[0] == "explain" then
      ARGV.shift
      explain = true
      mode    = ARGV.shift
   else
      mode    = ARGV.shift
   end
      

   case mode
      when nil, "parse"
         parser_plan.display( STDOUT, "", true, ARGV[0].nil? ? :reduce_determinants : ARGV[0].intern ) if explain

         lexer  = RCC::Interpreter::Lexer.new( STDIN, "<stdin>" )
         parser = RCC::Interpreter::Parser.new( parser_plan, lexer )
         ast    = parser.parse( explain )
         
         if explain then
            STDOUT.puts ""
            STDOUT.puts ""
            STDOUT.puts ""
         end
           
         STDOUT.puts "ABSTRACT SYNTAX TREE" 
         STDOUT.puts "===================="
         STDOUT.puts ""
         ast.format().each do |line|
            STDOUT.puts line
         end
         
      when "lex"
         lexer = RCC::Interpreter::Lexer.new( STDIN, "<stdin>" )
         while token = lexer.next_token( parser_plan.lexer_plan, explain )
            if explain then
               puts "\n"
            else
               puts "[#{token.gsub("\n", "\\n")}]#{token.type.is_a?(Symbol) ? ":" + token.type.to_s : "" } at #{token.line_number}:#{token.column_number}"
            end
         end
         
         if lexer.input_remaining? then
            puts "UNRECOGNIZED INPUT at #{lexer.line_number}:#{lexer.column_number} [#{lexer.sample_unconsumed.gsub("\n", "\\n")}]"
         else
            puts "DONE"
         end
         
      else
         puts "Unsuppored mode: #{mode}; Supported modes: parse, lex"
         exit 10
   end
