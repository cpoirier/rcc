#!/usr/bin/env ruby
#================================================================================================================================
#
# Ruby Compiler Compiler (rcc)
#
# Copyright 2007 Chris Poirier (cpoirier@gmail.com)
# Licensed under the Academic Free License version 2.1
#
#================================================================================================================================

   require "#{File.dirname(File.expand_path(__FILE__))}/../rcc/environment.rb"
   require "#{$RCCLIB}/model/grammar.rb"
   require "#{$RCCLIB}/scanner/interpreter/lexer.rb"
   require "#{$RCCLIB}/scanner/interpreter/parser.rb"

   if ARGV.empty? then
      puts "USAGE: #{File.basename($0)} <grammar file> (explain? <mode>)?"
      puts "MODES: lex"
      exit 10
   end
   

   #
   # Load and compile the grammar.
   
   grammar_path = ARGV.shift
   grammar      = RCC::Model::Grammar.load_from_file( File.basename(grammar_path), grammar_path )
   grammar.display( STDOUT )


   #
   # Compile the parser plan.
   
   $show_statistics = true
   
   parser_plan = grammar.compile_plan()
   parser_plan.compile_actions( true )
   
   STDOUT.puts ""
   STDOUT.puts ""
   STDOUT.puts ""
   
   
   #
   # Process the input.  If mode is "lex", we will run the lexer over the input and do no parsing.
   # Otherwise, we parse.
   
   explain = false
   if ARGV[0] == "explain" then
      ARGV.shift
      explain = true
      mode    = ARGV.shift
   else
      mode    = ARGV.shift
   end
      

   case mode
      when nil, "parse", "recovery"
         parser_plan.display( STDOUT, "", true, ARGV[0].nil? ? :reduce_determinants : ARGV[0].intern ) if explain

         source   = RCC::Scanner::Interpreter::Source.new( STDIN.read, "<stdin>" )
         lexer    = RCC::Scanner::Interpreter::Lexer.new( source )
         parser   = RCC::Scanner::Interpreter::Parser.new( parser_plan, lexer )
         solution = parser.parse( 3, explain ? "" : nil )

         if explain then
            STDOUT.puts ""
            STDOUT.puts ""
            STDOUT.puts ""
         end
      
         if solution.valid? then
            STDOUT.puts "ABSTRACT SYNTAX TREE" 
            STDOUT.puts "===================="
            STDOUT.puts ""
         
            if ast.nil? then
               STDOUT.puts "?"
            else
               ast.format().each do |line|
                  STDOUT.puts line
               end
            end
         else
            STDERR.puts ""
            solution.report_errors( STDERR, 0.95, "" )
         end
         
      when "lex"
         lexer = RCC::Scanner::Interpreter::Lexer.new( STDIN, "<stdin>" )
         while token = lexer.next_token( parser_plan.lexer_plan, explain ? "" : nil )
            if explain then
               puts "\n"
            else
               puts "[#{token.gsub("\n", "\\n")}]#{token.type.is_a?(Symbol) ? ":" + token.type.to_s : "" } at #{token.line_number}:#{token.column_number}"
            end
         end
         
         if lexer.input_remaining? then
            puts "UNRECOGNIZED INPUT at #{lexer.line_number}:#{lexer.column_number} [#{lexer.sample_unconsumed.gsub("\n", "\\n")}]"
         else
            puts "DONE"
         end
         
      else
         puts "Unsuppored mode: #{mode}; Supported modes: parse, recovery, lex"
         exit 10
   end
