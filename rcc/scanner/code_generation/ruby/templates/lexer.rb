#!/usr/bin/env ruby
#================================================================================================================================
#
# Ruby Compiler Compiler (rcc)
#
# Copyright 2007 Chris Poirier (cpoirier@gmail.com)
# Licensed under the Academic Free License version 2.1
#
#================================================================================================================================
#
#  === DO NOT EDIT THIS FILE! ===
# 
#  It was GENERATED by rcc on %%GENERATION_DATE%%
#     from grammar "%%GRAMMAR_NAME%%"
#
#================================================================================================================================


require "#{File.dirname(File.expand_path(__FILE__))}/common.rb" 
require "#{File.dirname(File.expand_path(__FILE__))}/token.rb" 


%%MODULE_HEADER%%
 


 #============================================================================================================================
 # class Lexer
 #  - a reversible lexer

   class %%GRAMMAR_CLASS_NAME%%Lexer
      include Common
      
      
    #---------------------------------------------------------------------------------------------------------------------
    # Initialization and public interface
    #---------------------------------------------------------------------------------------------------------------------

      attr_reader :line_number
      attr_reader :column_number
      
      def initialize( input, descriptor )
         @line_reader   = LineReader.new( input, descriptor )    # The input stream from which we'll draw input
         @descriptor    = descriptor                             # A descriptor of the input, used during Token production
                                                                 
         @pending_lines = []     # Lines ahead of the lex() point in the @input (or @text)
         @position      = 0      # The @line_reader position at the lex() point
         @line_number   = 1      # The current line number, at the lex() point
         @column_number = 1      # The current column number, at the lex() point
         @last_consumed = nil    # The last Token consumed() (used for updating line and column numbers)
         
         @ignore_list   = [ %%IGNORE_LIST%% ]   # A list of the Token types we should never produce
      end
      

      #
      # next_token()
      #  - runs the lexer against the input until one token is produced or the input is exhausted
      
      def next_token( state_number )
         return self.call( "lex_for_state_#{state_number}" )
      end


      #
      # reset_position()
      #  - resets the position of the lexer
      
      def reset_position( to_position )
         @line_reader.seek( to_position )
         @pending_lines.clear()
         @last_consumed = nil
      end


      #
      # input_remaining?() 
      #  - returns true if there is input still to be processed
      
      def input_remaining?()
         return true unless @pending_lines.empty?
         return update_position()
      end






    #---------------------------------------------------------------------------------------------------------------------
    # Lexers
    #---------------------------------------------------------------------------------------------------------------------
    
    protected
    
    
      %%LEXERS%%





    
    #---------------------------------------------------------------------------------------------------------------------
    # Support code
    #---------------------------------------------------------------------------------------------------------------------
    
    protected
    
      #
      # make_token()
      #  - build a new Token from the current data
      
      def make_token( string, type = nil )
         return Token.new( string, type, @position, @line_number, @column_number, @descriptor )
         
      end
      
      
      #
      # la()
      #  - looks ahead one or more characters
      #  - reads write through line boundaries, if necessary
      
      def la( count = 1 )
         c = nil
         
         if update_position() then
            line = 0
            while c.nil?
               if count <= @pending_lines[line].length then
                  c = @pending_lines[line].slice(count-1, 1)
               else
                  line += 1
                  read_ahead( line ) or break
               end
            end
         end
         
         return c
      end
      
      
      #
      # consume()
      #  - shifts the next character off the lookahead and returns it
      
      def consume( count = 1 )
         c = nil
         if c = la(count) then 
            @last_consumed = @pending_lines[0].slice!(0, count)
         end
         
         return c
      end


      #
      # consume_match()
      #  - applies a Regexp to the unconsumed portion of the current line
      #  - if a match occurs, consumes those characters and returns them
      #  - matches must be wholly contained within the current line
      
      def consume_match( regexp )
         match = nil
         
         if update_position() then
            if @pending_lines[0] =~ regexp and $`.length == 0 then
               match = @pending_lines[0].slice!(0, $&.length)
               @last_consumed = match
            end
         end
         
         return match
      end
      
      
      #
      # update_position()
      #  - ensures the line buffer is full and adjusts the position markers to account for the last data consumed 
      #    (if not already done)

      def update_position()
         unless @last_consumed.nil?
            @position += @last_consumed.length
            
            if @pending_lines[0].empty? then
               @pending_lines.shift
               @column_number = 1
               @line_number  += 1
            else
               @column_number += @last_consumed.length
            end

            @last_consumed = nil
         end

         if @pending_lines.empty?() then
            read_ahead() or return false
         end

         return true
      end
      
      
      #
      # read_ahead( lines = 1 )
      #  - reads the next line from the input until a certain number of lines are in the buffer
      
      def read_ahead( lines = 1 )
         if @pending_lines.empty? then
            @position      = @line_reader.position
            @line_number   = @line_reader.line_number
            @column_number = @line_reader.column_number
         end
            
         while @pending_lines.length < lines
            if line = @line_reader.gets then
               @pending_lines << line
            else
               return false
            end
         end
         
         return true
      end
   
      
   end # %%GRAMMAR_CLASS_NAME%%Lexer
   

%%MODULE_FOOTER%%
