#!/usr/bin/env ruby
#================================================================================================================================
# RCC
# Copyright 2007-2008 Chris Poirier (cpoirier@gmail.com)
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the 
# License.  You may obtain a copy of the License at
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" 
# BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language 
# governing permissions and limitations under the License.
#================================================================================================================================
#
#  === DO NOT EDIT THIS FILE! ===
# 
#  It was GENERATED by rcc on %%GENERATION_DATE%%
#     from grammar "%%GRAMMAR_NAME%%"
#
#================================================================================================================================


require "#{File.dirname(File.expand_path(__FILE__))}/common.rb" 
require "#{File.dirname(File.expand_path(__FILE__))}/node.rb" 


%%MODULE_HEADER%%
 


 #============================================================================================================================
 # class Parser
 #  - not much I can say here . . . 

   class %%GRAMMAR_CLASS_NAME%%Parser
      include Common
      
      

    #---------------------------------------------------------------------------------------------------------------------
    # Initialization and public interface
    #---------------------------------------------------------------------------------------------------------------------
    
    
      #
      # initialize()
   
      def initialize()
         @node_stack  = nil
         @state_stack = nil
         @lookahead   = []
         @lexer       = nil
         @lexer_state = nil
      end
      
      
      
      #
      # parse()
      #  - parses an input
      
      def parse( input_stream, input_descriptor = nil )
         
         #
         # Initialize the Parser and Lexer for the coming work.
         
         @lexer = %%GRAMMAR_CLASS_NAME%%Lexer.new( input_stream, input_descriptor )
         @state_stack = [ @@states[0] ]
         @node_stack  = []
         action       = nil
         
         
         #
         # Do the work.
         
         while true
            
            state = state_stack[-1]
            set_lexer_state( state )
            
            #
            # Determine our next action, based on lookahead.
            
            next_token = la(1)
            token_type = (next_token.nil? ? nil : next_token.type)
            action     = state.actions[token_type]
            
            #
            # Process the action.
         
            if action.nil? then
               nyi( "error handling for bad lookahead: [#{next_token.text}]:#{next_token.type}" )
            elsif action.accept? then
               break
            else
               action.perform( self )
            end
         end
         
         
         return node_stack[-1]
      end
      






    #---------------------------------------------------------------------------------------------------------------------
    # Support classes.
    #---------------------------------------------------------------------------------------------------------------------

      
      class State
         attr_reader :number
         attr_reader :actions
         def initialize( number )
            @number  = number
            @actions = {}
         end
      end
      
      class Production
         attr_reader :name
         attr_reader :name_number
         attr_reader :node_type
         attr_reader :symbol_count
         attr_reader :slot_mappings
         attr_reader :asn_class
         attr_reader :processor_name
         attr_reader :production_processor_name
         
         def initialize( name, name_number, node_type, symbol_count, slot_mappings, asn_class = nil )
            @name           = name
            @name_number    = name_number
            @node_type      = node_type
            @symbol_name    = symbol_name
            @slot_mappings  = slot_mappings
            @asn_class      = asn_class
            
            @processor_name            = "process_#{@name}"
            @production_processor_name = "#{@processor_name}__production_#{@name_number}"
         end
         
         def enslot_nodes( nodes )
            slots = {}
            @slot_mappings.each do |index, name|
               slots[name] = nodes[index]
            end
            return slots
         end
      end
      
      class Action
         def accept?()
            return false
         end
      end
      
      class ShiftAction < Action
         attr_reader :to_state
         def initialize( to_state )
            @to_state = to_state
         end
         
         def perform( parser )
            to_state = @to_state
            parser.instance_eval do
               @node_stack  << consume()
               @state_stack << to_state
            end
         end
      end
      
      class ReduceAction < Action
         attr_reader :by_production
         def initialize( by_production )
            @by_production = by_production
         end
         
         def perform( parser )
            by_production = @by_production
            parser.instance_eval do
               node        = reduce_by( by_production )
               top_state   = @state_stack[-1]
               goto_action = state.actions[node.type]
               
               @node_stack  << node
               @state_stack << goto_action.to_state
            end
         end
      end
      
      class GotoAction < Action
         attr_reader :to_state
         def initialize( to_state )
            @to_state = to_state
         end
         
         def perform( parser )
            bug( "GotoAction.perform should never be called" )
         end
      end
      

      class AcceptAction < Action
         def accept?()
            return true
         end
      end




      

    #---------------------------------------------------------------------------------------------------------------------
    # Productions
    #---------------------------------------------------------------------------------------------------------------------
    
    protected    
    
      %%PRODUCTIONS%%




    
    #---------------------------------------------------------------------------------------------------------------------
    # States
    #---------------------------------------------------------------------------------------------------------------------
    
    protected    
    
      %%STATES%%
    
    
    
    
    
    #---------------------------------------------------------------------------------------------------------------------
    # Support code
    #---------------------------------------------------------------------------------------------------------------------
    
    protected

      #
      # reduce_by()
      #  - reduces nodes from the stack to a new node, using a Production
      #  - returns the new Node
      
      def reduce_by( production )
         produced_node = nodes = nil
         
         #
         # First up, pop off the requisite number of objects from the node stack.  We also discard the same number of items 
         # from the other stacks.  Note that, for production purposes, we want the nodes in oldest-to-newest order. 
         
         nodes = @node_stack.slice!(  -production.symbol_count..-1  )
                 @state_stack.slice!( -production.symbol_count..-1  )
         %%REDUCE_PROCESSING%%

         #
         # Return the produced Node.
         
         return produced_node
      end
      
      
      #
      # rewind()
      #  - rewinds the Lexer to where it was when it produced the specified token
      
      def rewind( before_token )
         @lexer.reset_position( before_token.start_position )
         @lookahead.clear
      end
      
      
      #
      # set_lexer_state( state )
      #  - changes the state from which the Lexer will lex
      #  - discards any unused lookahead
      
      def set_lexer_state( state )
         unless @lexer_state.number == state.number
            unless @lookahead.empty?
               rewind( @lookahead[0] )
               @lookahead.clear
            end
            
            @lexer_state = state
         end
      end

      
      #
      # la() 
      #  - looks ahead one or more tokens
      
      def la( count = 1 )
         until @lookahead.length >= count
            if token = @lexer.next_token( @lexer_state.number ) then
               @lookahead << token
            else
               nyi "error handling for lexer error" if @lexer.input_remaining?
               break
            end
         end
         
         return @lookahead[count - 1]
      end


      #
      # consume()
      #  - shifts the next token off the lookahead and returns it
      
      def consume()
         la(1)
         return @lookahead.shift
      end


    
      
   end # %%GRAMMAR_CLASS_NAME%%Parser
   

%%MODULE_FOOTER%%
